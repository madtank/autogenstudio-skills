{
  "version": "1.0.0",
  "component_type": "team",
  "name": "new_team_1737352488588",
  "participants": [
    {
      "component_type": "agent",
      "name": "assistant_agent",
      "agent_type": "AssistantAgent",
      "system_message": "You are a helpful assistant. Solve tasks carefully. You have a tool called MCP, this is USB for llm context, it's a set of tools. You will be asked to do MCP tools tests and validate the different options you can use with them. When the task is done respond with TERMINATE.",
      "model_client": {
        "component_type": "model",
        "model": "gpt-4o-2024-08-06",
        "model_type": "OpenAIChatCompletionClient"
      },
      "tools": [
        {
            "component_type": "tool",
            "name": "mcp",
            "description": "Access MCP (Model Context Protocol) servers with focus on two key capabilities:\n\n1. List available servers\n   Example: mcp(tool='list_available_servers')\n\n2. Get details about tools on a server\n   Example: mcp(server='server_name', tool='tool_details')\n\nMain servers include:\n- filesystem: For file operations\n- brave-search: For web search capabilities\n\nIMPORTANT:\n1. Always check tool details before use to understand required parameters and proper usage. Do not make assumptions about how tools work - use tool_details to verify the correct parameters and format.\n\n2. The user cannot see the raw tool results - you must always provide a clear summary of what the tool did and what was found. For example:\n   - When reading a file: Explain what was in the file\n   - When searching: Summarize the search results\n   - When listing directories: Describe what was found\n\nNever just execute a tool without explaining its results to the user. Always interpret and explain the output in a way that's meaningful to the user.",
            "content": "async def mcp(server: str = None, tool: str = None, query: str = None, path: str = None, count: int = None) -> str:\n    \"\"\"MCP (Model Context Protocol) provides access to various tools and servers.\n    Before using any tools, you should:\n\n    1. List available servers:\n       mcp(tool='list_available_servers')\n\n    2. Get details about tools on a server:\n       mcp(server='server_name', tool='tool_details')\n\n    Main servers include:\n    - filesystem: For file operations \n    - brave-search: For web search capabilities\n\n    IMPORTANT: Always check tool details before use to understand required parameters\n    and proper usage. Do not make assumptions about how tools work - use tool_details\n    to verify the correct parameters and format.\n\n    The user cannot see the raw tool results - you must always provide a clear summary\n    of what the tool did and what was found. For example:\n    - When reading a file: Explain what was in the file\n    - When searching: Summarize the search results\n    - When listing directories: Describe what was found\n\n    Never just execute a tool without explaining its results to the user. Always interpret\n    and explain the output in a way that's meaningful to the user.\n    \"\"\"\n    try:\n        import json\n        import asyncio\n        import os\n        import platform\n        from pathlib import Path\n        from mcp import ClientSession, StdioServerParameters\n        from mcp.client.stdio import stdio_client\n\n        # Get system-specific config path\n        system = platform.system()\n        home = Path.home()\n        \n        if system == \"Darwin\":  # macOS\n            config_path = home / \"Library/Application Support/Claude/claude_desktop_config.json\"\n            default_npx = Path(\"/opt/homebrew/bin/npx\")\n        elif system == \"Windows\":\n            config_path = Path(os.getenv(\"APPDATA\")) / \"Claude/claude_desktop_config.json\"\n            default_npx = Path(os.getenv(\"APPDATA\")) / \"npm/npx.cmd\"\n        else:  # Linux and others\n            config_path = home / \".config/Claude/claude_desktop_config.json\"\n            default_npx = Path(\"/usr/local/bin/npx\")\n\n        # Find npx in PATH if default doesn't exist\n        npx_path = str(default_npx if default_npx.exists() else \"npx\")\n\n        # Load config\n        with open(config_path) as f:\n            servers = json.load(f).get('mcpServers', {})\n\n        # Handle special tool cases first\n        if tool == 'list_available_servers':\n            return json.dumps(list(servers.keys()), indent=2)\n\n        # Require server parameter for all other operations\n        if not server:\n            return \"Error: Server parameter required for tool operations\"\n        if server not in servers:\n            return f\"Error: Server {server} not found\"\n\n        # Build server config\n        config = servers[server]\n        command = npx_path if config['command'] == 'npx' else config['command']\n        env = os.environ.copy()\n        env.update(config.get('env', {}))\n\n        # Build arguments based on tool\n        args = {}\n        if path is not None:\n            args['path'] = path\n        if query is not None:\n            args['query'] = query\n        if count is not None:\n            args['count'] = count\n\n        # Execute tool\n        async with stdio_client(StdioServerParameters(command=command, args=config.get('args', []), env=env)) as (read, write):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n                if tool == 'tool_details':\n                    result = await session.list_tools()\n                    return json.dumps([{\n                        'name': tool.name,\n                        'description': tool.description,\n                        'input_schema': tool.inputSchema\n                    } for tool in result.tools], indent=2)\n                result = await session.call_tool(tool, arguments=args)\n                return str(result)\n\n    except Exception as e:\n        return f\"Error: {str(e)}\"",
            "tool_type": "PythonFunction"
        }
      ]
    }
  ],
  "team_type": "RoundRobinGroupChat",
  "termination_condition": {
    "component_type": "termination",
    "termination_type": "TextMentionTermination",
    "text": "TERMINATE"
  }
}